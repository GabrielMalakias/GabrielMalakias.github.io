I"®.<p>Hello everyone, Today I will talk about how Iâ€™m using the LiteCable/Anycable and MQTT to display data on my dashboard. I made a huge number of changes on my views changing it to use the <a href="http://materializecss.com">Materializecss</a> instead bootstrap, however I not going to talk about it, not yet. Well Iâ€™ve shown how can we use anycable, but itâ€™s only a battle to reach the illumination. Well, today Iâ€™m going to show how I connected the Websocket with the MQTT, If I could tell something now I think would be that it was the easiest part so far, but I can share some details with you. Letâ€™s start with a map and here it is.</p>

<p><img src="http://localhost:4000/assets/images/usgard_detailed_architecture.png" alt="Usgard detailed architecture" /></p>

<p>As you could see above there are not only many moving parts but also bidirectional communication waysâ€¦ Ok I know, but câ€™mon I added just one part, the MQTT. In the previous post I wrote regarding what is and showed how to use LiteCable, so if you donâ€™t saw the previous post <a href="http://gabrielmalakias.com.br/ruby/hanami/iot/2017/05/25/websockets-connecting-litecable-to-hanami.html">please check it out before continue</a> :).</p>

<p>Now we have a broker that is responsible to handle all connections. The MQTT broker is basically currently my single point of failure, but Iâ€™m not worried about it yet, here are some docker stats:</p>

<p><img src="http://localhost:4000/assets/images/docker_stats_usgard.png" alt="Usgard detailed architecture" /></p>

<ul>
  <li><em>Itâ€™s not a very precise test but I ran a ruby publisher using a sleep time of 0.001 and works well. I tests were made only on my machine</em></li>
</ul>

<p>To connect on MQTT Iâ€™m using this <a href="https://github.com/njh/ruby-mqtt">gem(ruby-mqtt)</a>. I simply added the following line to my Gemfile.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">gem</span> <span class="s1">'mqtt'</span></code></pre></figure>

<p>After that we have to build not only the code to subscribe all topics needed but also to broadcast messages through websockets to the related channel, Iâ€™m using the code below.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s2">"rack"</span>
<span class="nb">require</span> <span class="s2">"anycable"</span>
<span class="nb">require</span> <span class="s2">"litecable"</span>
<span class="nb">require</span> <span class="s2">"mqtt"</span>

<span class="c1"># we must enable the compatibility mode as was made in anycable server file.</span>
<span class="no">LiteCable</span><span class="p">.</span><span class="nf">anycable!</span>

<span class="c1"># Here we have the mqtt connection</span>
<span class="n">client</span> <span class="o">=</span> <span class="no">MQTT</span><span class="o">::</span><span class="no">Client</span><span class="p">.</span><span class="nf">connect</span><span class="p">(</span><span class="ss">host: </span><span class="s1">'mqtt'</span><span class="p">,</span> <span class="ss">port: </span><span class="mi">1883</span><span class="p">)</span>

<span class="c1"># Subscribing topics needed</span>
<span class="n">client</span><span class="p">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="s2">"sensor/#"</span><span class="p">)</span>
<span class="n">client</span><span class="p">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="s2">"actuator/#"</span><span class="p">)</span>

<span class="n">client</span><span class="p">.</span><span class="nf">get</span> <span class="k">do</span> <span class="o">|</span><span class="n">topic</span><span class="p">,</span> <span class="n">message</span><span class="o">|</span>
  <span class="n">topic</span> <span class="o">=</span> <span class="n">topic</span><span class="p">.</span><span class="nf">gsub</span><span class="p">(</span><span class="s1">'/'</span><span class="p">,</span> <span class="s1">'_'</span><span class="p">)</span>

  <span class="c1"># Broadcasts to the websockets in a specific channel</span>
  <span class="no">LiteCable</span><span class="p">.</span><span class="nf">broadcast</span> <span class="n">topic</span><span class="p">,</span> <span class="ss">user: </span><span class="s1">'external'</span><span class="p">,</span> <span class="ss">message: </span><span class="n">message</span><span class="p">,</span> <span class="ss">sid: </span><span class="no">Random</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">99999</span><span class="p">)</span>
<span class="k">end</span></code></pre></figure>

<p>Well, when we execute â€˜client.getâ€™ the execution thread will loop getting packets forever. How I know it? I searched into the gem and discovered how the method â€˜getâ€™ works. The code is very well documented then thanks <a href="https://twitter.com/njh">@njh</a>, great work! I printed some pieces of code, so here it is.</p>

<p><img src="http://localhost:4000/assets/images/mqtt_ruby_get.png" alt="Njh client.get" /></p>

<p>And how it gets incoming packets from MQTT topics</p>

<p><img src="http://localhost:4000/assets/images/mqtt_ruby_get_packet.png" alt="Njh client.get_packet" /></p>

<p>As I mentioned previously Iâ€™m using docker-compose to separate the responsabilities in little containers avoiding tools like god or systemd on docker. The subscribe script runs as a daemon inside the container, summing up we have to add a new container to docker-compose.yml.</p>

<figure class="highlight"><pre><code class="language-yml" data-lang="yml"><span class="s">// More code here...</span>
  <span class="s">subscriber</span><span class="err">:</span>
    <span class="na">build</span><span class="pi">:</span> <span class="s">.</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">bundle exec ruby subscriber</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">.:/usgard</span>
    <span class="na">env_file</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">.env.development</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">ANYCABLE_REDIS_URL=redis://redis:6379/0</span>
    <span class="na">depends_on</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">redis</span>
      <span class="pi">-</span> <span class="s">db</span>
      <span class="pi">-</span> <span class="s">mqtt</span></code></pre></figure>

<p>Now it works!</p>

<p><img src="http://localhost:4000/assets/images/usgard_dashboard_working.gif" alt="Usgard Dashboard" /></p>

<p>Ok, Now we receive data from MQTT on dashboard but on the actuatorâ€™s page we have it the following feature:</p>

<p><img src="http://localhost:4000/assets/images/usgard_dashboard_console.png" alt="Usgard Console" /></p>
<ul>
  <li><em>We have a console, using it we have to send data to actuators</em></li>
</ul>

<p>So, how can we send data to an mqtt topic? Itâ€™s just send to â€˜actuators/1â€™, isnâ€™t it? Almost there padawan because we donâ€™t want to see the same data that we send. So, when we send data to MQTT we have to use a different topic, for example â€˜actuators/1/sendâ€™. I already show how connect the websocket with the panel using the litecable channel then we have to change the Actuators channel to send data to MQTT, something like the code below.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="c1"># frozen_string_literal: true</span>

<span class="k">module</span> <span class="nn">Usgard</span>
  <span class="k">module</span> <span class="nn">Ws</span>
    <span class="k">class</span> <span class="nc">Channel::Actuator</span> <span class="o">&lt;</span> <span class="no">Usgard</span><span class="o">::</span><span class="no">Ws</span><span class="o">::</span><span class="no">Channel</span>
      <span class="n">identifier</span> <span class="ss">:actuator</span>

      <span class="k">def</span> <span class="nf">subscribed</span>
        <span class="n">reject</span> <span class="k">unless</span> <span class="n">actuator_id</span>
        <span class="n">stream_from</span> <span class="s2">"actuator_</span><span class="si">#{</span><span class="n">actuator_id</span><span class="si">}</span><span class="s2">"</span>
      <span class="k">end</span>

      <span class="k">def</span> <span class="nf">speak</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="no">Hanami</span><span class="o">::</span><span class="no">Logger</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">info</span> <span class="s2">"</span><span class="si">#{</span><span class="vi">@user</span><span class="si">}</span><span class="s2"> connected"</span>
        <span class="no">LiteCable</span><span class="p">.</span><span class="nf">broadcast</span> <span class="s2">"actuator_</span><span class="si">#{</span><span class="n">actuator_id</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span> <span class="ss">user: </span><span class="n">user</span><span class="p">,</span> <span class="ss">message: </span><span class="n">data</span><span class="p">[</span><span class="s2">"message"</span><span class="p">],</span> <span class="ss">sid: </span><span class="n">sid</span>

        <span class="n">send_to_mqtt</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">'message'</span><span class="p">])</span>
      <span class="k">end</span>

      <span class="kp">private</span>

      <span class="k">def</span> <span class="nf">send_to_mqtt</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
        <span class="c1"># creates the client connection</span>
        <span class="vi">@client</span> <span class="o">||=</span> <span class="no">MQTT</span><span class="o">::</span><span class="no">Client</span><span class="p">.</span><span class="nf">connect</span><span class="p">(</span><span class="ss">host: </span><span class="s1">'mqtt'</span><span class="p">,</span> <span class="ss">port: </span><span class="mi">1883</span><span class="p">)</span>

        <span class="c1"># publishes on actuators output topic</span>
        <span class="vi">@client</span><span class="p">.</span><span class="nf">publish</span><span class="p">(</span><span class="s2">"actuator/</span><span class="si">#{</span><span class="n">actuator_id</span><span class="si">}</span><span class="s2">/send"</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
      <span class="k">end</span>

      <span class="k">def</span> <span class="nf">actuator_id</span>
        <span class="vi">@actuator_id</span> <span class="o">||=</span> <span class="n">params</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="s2">"id"</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>To conclude now the Usgard dashboard is able to receive and send data through MQTT using Websockets. On the next post I will start to talk about both the Bridge, the Bitfrost project, and also about Java, Optionals, Threads and RXTX. I will talk again about Usgard project and Hanami later, donâ€™t worry :) (I maybe write about Vue.js and Rodauth). Thank you, and please give your opinion about it, it makes me happy :).</p>

<h3 id="references">References</h3>

<ul>
  <li>http://materializecss.com</li>
  <li>https://github.com/njh/ruby-mqtt</li>
</ul>

:ET